# Лесникова Полина ИТ - 6 Лабораторная №5

# Задание 1
## Задача 1
### Текст задачи:
В	 класс	Дробь,	 добавить	интерфейс	на	 два	метода:	 получение	 вещественного	 значения,	 установка	
числителя	и	установка	знаменателя.

Сгенерировать	 такую	 версию	 дроби,	 которая	 будет	 кэшировать	 вычисление	 вещественного	
значения.

Если	 раннее	 в	 вашем	 варианте	 не	 было	 Дроби,	 то	 создайте	 сущность Дробь	 со	 следующими	
особенностями:
- Имеет	числитель:	целое	число
- Имеет	знаменатель:	целое	число
- Дробь	может	быть	создана	с	указанием	числителя	и	знаменателя	
- Может	вернуть	строковое	представление	вида	“числитель/знаменатель”
- Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может
быть отрицательным.
- Переопределите	метод	сравнения	объектов	по	состоянию	таким	образом,	чтобы	две	дроби	считались	одинаковыми	тогда, когда	у	них	одинаковые	значения	числителя	и	знаменателя.
### Алгоритм:
Создать интерфейс FractionInterface с методами:
- getRealValue() — получение вещественного значения
- setNumerator(int numerator) — установка числителя
- setDenominator(int denominator) — установка знаменателя

Реализовать класс Task1_1 с полями:
- numerator — числитель
- denominator — знаменатель
- cachedRealValue — кэшированное значение
- isCacheValid — флаг кэша

Логика работы:
- При создании дроби проверять, что знаменатель != 0
- Если знаменатель отрицательный, переносить знак в числитель
- При каждом вызове getRealValue():
  - Если кэш нету -> вычислять значение и сохранять в кэш
  - Если кэш есть -> возвращать кэшированное значение
- При изменении числителя или знаменателя сбрасывать кэш
- Переопределить equals() для сравнения по числителю и знаменателю
- Переопределить toString() в формате "числитель/знаменатель"

# Задание 2
## Задача 1
### Текст задачи:
Количество мяуканий.

Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.

Если	раннее	в	вашем	варианте	не	было	Кота,	то	создайте	
1. сущность	Кот,	которая	описывается	следующим	образом:
- Имеет	Имя	(строка)
- Для	создания	необходимо	указать	имя	кота.
- Может	быть	приведен	к	текстовой	форме	вида:	“кот:	Имя”
- Может	 помяукать,	 что	 приводит	 к	 выводу	 на	 экран	 следующего	 текста:	“Имя:	мяу!”,	
вызвать	мяуканье	можно	без	параметров.
2. интерфейс	 Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:

public void meow();
### Алгоритм:
Создать интерфейс Meowing с методом meow()

Создать класс Cat (если его не было), реализующий Meowing:
- Поля: name (строка), meowCount (счётчик мяуканий)
- Конструктор принимает имя
- Метод meow():
  - Выводит "{имя}: мяу!"
  - Увеличивает счётчик мяуканий на 1
- Метод getMeowCount() возвращает количество мяуканий

Создать класс Task2_1 с методом makeAllMeow():
- Принимает список объектов Meowing
- Для каждого объекта вызывает метод meow()

# Задание 3
## Задача 1
### Текст задачи:
Составить	программу,	которая	удаляет	из	списка	L	все	элементы	E,	если	такие	есть
### Алгоритм:
Создать метод removeAllOccurrences() с параметрами:
- List<T> list — исходный список
- T element — элемент для удаления

Реализация:
- Создать копию исходного списка
- Пройти по всем элементам исходного списка
- Если текущий элемент равен element, удаляем
- Использовать equals() для сравнения элементов
- Вернуть список

# Задание 4
## Задача 1
### Текст задачи:
На	 вход	 программы	 подаются	 фамилии	 и	 имена	 учеников.	 Известно,	 что	 общее	 количество	
учеников	 не	 превосходит	 100.	 В	 первой	 строке	 вводится	 количество	 учеников,	 принимавших	
участие	в	соревнованиях,	N.	Далее	следуют	N	строк,	имеющих	следующий	формат:

<Фамилия><Имя>

Здесь	<Фамилия> – строка,	состоящая	не	более	чем	из	20	символов;	<Имя>– строка,	состоящая	не	
более	чем	из	15	символов. При	этом	<Фамилия> и	<Имя> разделены	одним	пробелом.	Примеры	
входных	строк:	

Иванова	Мария

Петров	Сергей

Требуется	написать	программу,	которая	формирует	и	печатает	уникальный	логин	для	каждого	
ученика	по	следующему	правилу:	если	фамилия	встречается	первый	раз,	то	логин	– это	данная	
фамилия,	 если	 фамилия	 встречается	 второй	 раз,	 то	 логин	 – это	 фамилия,	 в	 конец	 которой	
приписывается	число	2	и	т.д.	
Например,	для	входной	последовательности:

Иванова	Мария

Петров	Сергей

Бойцова	Екатерина

Петров	Иван

Иванова	Наташа

будут	сформированы	следующие	логины:

Иванова

Петров

Бойцова

Петров2

Иванова2
### Алгоритм:
- Список строк формата "Фамилия Имя" записывается в файл
- Файл распаковывается в список

Создать метод generateLogins():
- Вход: List<String> students
- Выход: List<String> logins

Логика:
- Создать HashMap<String, Integer> для подсчёта фамилий
- Создать пустой список для результатов
- Для каждого ученика:
  - Разделить строку на фамилию и имя
  - Извлечь фамилию (первое слово)
  - Получить текущий счётчик для этой фамилии
  - Увеличить счётчик на 1
  - Если счётчик = 1 → логин = фамилия
  - Если счётчик > 1 → логин = фамилия + счётчик
  - Добавить логин в результирующий список
- Вернуть список логинов

# Задание 5
## Задача 1
### Текст задачи:
Файл	 содержит	 текст	 на	 русском	 языке.	 Напечатать	 в	 алфавитном	 порядке	 все	 звонкие	
согласные	буквы,	которые	входят	хотя	бы	в	одно	слово.
### Алгоритм:
Определить множество звонких согласных русского алфавита:
- б, в, г, д, ж, з, й, л, м, н, р

Создать метод findVoicedConsonants():
- Вход: String text (текст на русском языке)
- Выход: Set<Character> (уникальные звонкие согласные)

Логика:
- Привести весь текст к нижнему регистру
- Создать TreeSet<Character> для автоматической сортировки
- Пройти по всем символам текста:
  - Если символ содержится в множестве звонких согласных
  - Добавить его в TreeSet
- Вернуть отсортированное множество

# Задание 6
## Задача 5
### Текст задачи:
Переписать	элементы	из	очереди	L1 в	очередь	L2	в	обратном	порядке
### Алгоритм:
Создать метод reverseQueue():
- Вход: Queue<T> queue (исходная очередь)
- Выход: Queue<T> (очередь в обратном порядке)

Использовать стек как промежуточную структуру:
- Пока исходная очередь не пуста:
  - Извлечь элемент из очереди (poll())
  - Поместить элемент в стек (push())
- Пока стек не пуст:
  - Извлечь элемент из стека (pop())
  - Поместить элемент в новую очередь (offer())
- Вернуть новую очередь

# Задание 7
## Задача 1
### Текст задачи:
Необходимо	написать	стрим:
Дан	 набор	 объектов	 типа	 Point,	 необходимо	 взять	 все	 Point	 в	 разных	 координатах,	 убрать	 с	
одинаковыми	X,Y, отсортировать	по	X,	отрицательные	Y	сделать	положительными	и	собрать	это	
все	в	ломаную	(объект	типа	Polyline)

Если	раннее	в	вашем	варианте	не	было	задание	с	классом	Point и	Polyline,	то	написать	их:
1. класс	Point:
- Координата	Х:	число.		
- Координата	Y:	число.
- Может	возвращать	текстовое	представление	вида	“{X;Y}”.
2. класс	Line (Линия),	расположенная на	двумерной	плоскости,	которая	описывается:
- Координата	начала:	Точка
- Координата	конца:	Точка
- Может	возвращать	текстовое	представление	вида	“Линия	от	{X1;Y1}	до	{X2;Y2}”
3. класс	 Polyline (Ломаная),	 которая	 будет	 представлять	 собой	 ломаную	 линию.	 Ломаная	
линия	представляет	собой	набор	следующих	характеристик:		
- Имеет	массив	Точек,	через	которые	линия	проходит.
- Может	 быть	 приведена	 к	 строковой	 форме	 вида	 “Линия	 [Т1,T2,…,TN]”,	 где	 TN	 – это результат	приведения	к	строке	Точки	с	номером	N
### Алгоритм:
Класс Point:
- Поля: x, y (double)
- Метод toString(): "{x;y}"
- Переопределить equals()

Класс Line:
- Поля: start, end (Point)
- Метод toString(): "Линия от {x1;y1} до {x2;y2}"

Класс Polyline:
- Поле: список Line
- Метод toString(): "Ломаная [точка1, точка2, ...]"

Класс Task7_1:
- Метод processPoints() с параметром:
  - список Point
  - Использовать Stream API:
    - distinct() — убрать дубликаты точек
    - sorted(Comparator.comparingDouble(Point::getX)) — сортировать по X
    - map(p -> new Point(p.getX(), Math.abs(p.getY()))) — сделать Y положительным
  - Создать линии из последовательных точек
  - Вернуть Polyline

# Задание 7
## Задача 2
### Текст задачи:
Дан	текстовый	файл	со строками, содержащими	имя	человека	и	его	номер	в	следующей	форме:

Вася:5

Петя:3

Аня:5

Номера	людей	могут	повторяться. У	каких-то	людей	может	не	быть	номера.
Необходимо	написать	стрим выполняющую	следующее:
читаются	 все	 люди	 из	 файла,	 все	 имена	 приводится	 к	 нижнему	 регистру,	 но	 с	 первой	 буквой	 в	
верхнем	регистре,	убираем	из	перечня	всех	людей	без	номеров,	а	имена	оставшихся	группируются	
по	их	номеру:

[5:[Вася,	Аня],	3:[Петя]]
### Алгоритм:
- запись данных в файл "Имя:Номер" или просто "Имя"
- Метод processPeopleFile():
  - Читать все строки из файла (Files.lines())
  - Для каждой строки:
    - Разделить по ":"
      - Если нет номера -> Person с number = null
      - Если есть номер -> преобразовать в Integer
    - Отфильтровать людей без номеров (filter(person -> person.getNumber() != null))
  - Для оставшихся:
    - Привести имя к нижнему регистру
    - Сделать первую букву заглавной
    - Сгруппировать по номеру:
      - Collectors.groupingBy(Person::getNumber)
      - Собрать имена в список
  - Результат: Map<Integer, List<String>>
